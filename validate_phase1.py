#!/usr/bin/env python3
"""
Validaƒçn√≠ skript pro F√°zi 1 - Profesionalizace k√≥du
Kontroluje, zda jsou splnƒõny v≈°echny krit√©ria p≈ôijet√≠
"""

import os
import sys
import importlib
import asyncio
from pathlib import Path
from typing import Dict, List, Any
import json


class Phase1Validator:
    """Valid√°tor pro krit√©ria p≈ôijet√≠ F√°ze 1"""
    
    def __init__(self):
        self.results = {
            "task_1_1_poetry": False,
            "task_1_2_secrets": False,
            "task_1_3_error_handling": False,
            "task_1_4_testing": False,
            "overall_score": 0
        }
        self.details = []
    
    def validate_all(self) -> Dict[str, Any]:
        """Provede kompletn√≠ validaci F√°ze 1"""
        print("üîç Spou≈°t√≠m validaci F√°ze 1: Refaktoring a Profesionalizace K√≥du\n")
        
        self._validate_poetry_management()
        self._validate_secrets_management()
        self._validate_error_handling()
        self._validate_testing_framework()
        
        self._calculate_overall_score()
        self._print_summary()
        
        return {
            "results": self.results,
            "details": self.details,
            "passed": self.results["overall_score"] >= 80
        }
    
    def _validate_poetry_management(self):
        """√ökol 1.1: Spr√°va z√°vislost√≠ pomoc√≠ Poetry"""
        print("üì¶ Validuji √∫kol 1.1: Spr√°va z√°vislost√≠ pomoc√≠ Poetry")
        
        checks = []
        
        # Check pyproject.toml existence
        pyproject_path = Path("pyproject.toml")
        if pyproject_path.exists():
            checks.append("‚úÖ pyproject.toml existuje")
            
            # Check tenacity dependency
            content = pyproject_path.read_text()
            if "tenacity" in content:
                checks.append("‚úÖ tenacity knihovna je v dependencies")
            else:
                checks.append("‚ùå tenacity knihovna chyb√≠ v dependencies")
        else:
            checks.append("‚ùå pyproject.toml neexistuje")
        
        # Check requirements.txt absence
        requirements_path = Path("requirements.txt")
        if not requirements_path.exists():
            checks.append("‚úÖ requirements.txt byl odstranƒõn")
        else:
            checks.append("‚ùå requirements.txt st√°le existuje")
        
        # Check Makefile updates (simplified check)
        makefile_path = Path("Makefile")
        if makefile_path.exists():
            content = makefile_path.read_text()
            if "poetry" in content:
                checks.append("‚úÖ Makefile obsahuje poetry p≈ô√≠kazy")
            else:
                checks.append("‚ö†Ô∏è  Makefile neobsahuje poetry p≈ô√≠kazy")
        
        success_rate = sum(1 for check in checks if check.startswith("‚úÖ")) / len(checks)
        self.results["task_1_1_poetry"] = success_rate >= 0.75
        
        self.details.extend(checks)
        print(f"   √öspƒõ≈°nost: {success_rate:.1%}\n")
    
    def _validate_secrets_management(self):
        """√ökol 1.2: Spr√°va konfigurac√≠ a tajemstv√≠"""
        print("üîê Validuji √∫kol 1.2: Spr√°va konfigurac√≠ a tajemstv√≠")
        
        checks = []
        
        # Check .env.example existence
        if Path(".env.example").exists():
            checks.append("‚úÖ .env.example existuje")
        else:
            checks.append("‚ùå .env.example neexistuje")
        
        # Check .env in .gitignore
        gitignore_path = Path(".gitignore")
        if gitignore_path.exists():
            content = gitignore_path.read_text()
            if ".env" in content:
                checks.append("‚úÖ .env je v .gitignore")
            else:
                checks.append("‚ùå .env nen√≠ v .gitignore")
        
        # Check new config system
        config_path = Path("src/core/config.py")
        if config_path.exists():
            checks.append("‚úÖ Nov√Ω konfiguraƒçn√≠ syst√©m existuje")
            
            content = config_path.read_text()
            if "pydantic" in content and "BaseSettings" in content:
                checks.append("‚úÖ Pou≈æ√≠v√° Pydantic pro type-safe config")
            else:
                checks.append("‚ùå Nepou≈æ√≠v√° Pydantic pro konfiguraci")
                
            if "os.getenv" in content or "env=" in content:
                checks.append("‚úÖ Naƒç√≠t√° z environment variables")
            else:
                checks.append("‚ùå Nenaƒç√≠t√° z environment variables")
        else:
            checks.append("‚ùå Nov√Ω konfiguraƒçn√≠ syst√©m neexistuje")
        
        # Check for hardcoded secrets in code
        hardcoded_found = self._scan_for_hardcoded_secrets()
        if not hardcoded_found:
            checks.append("‚úÖ ≈Ω√°dn√© hardcoded secrets nalezeny")
        else:
            checks.append(f"‚ùå Nalezeny hardcoded secrets: {len(hardcoded_found)}")
        
        success_rate = sum(1 for check in checks if check.startswith("‚úÖ")) / len(checks)
        self.results["task_1_2_secrets"] = success_rate >= 0.8
        
        self.details.extend(checks)
        print(f"   √öspƒõ≈°nost: {success_rate:.1%}\n")
    
    def _validate_error_handling(self):
        """√ökol 1.3: Robustn√≠ zpracov√°n√≠ chyb"""
        print("üõ°Ô∏è  Validuji √∫kol 1.3: Robustn√≠ zpracov√°n√≠ chyb")
        
        checks = []
        
        # Check error handling module
        error_handling_path = Path("src/core/error_handling.py")
        if error_handling_path.exists():
            checks.append("‚úÖ Error handling modul existuje")
            
            content = error_handling_path.read_text()
            
            if "tenacity" in content:
                checks.append("‚úÖ Pou≈æ√≠v√° tenacity pro retry")
            else:
                checks.append("‚ùå Nepou≈æ√≠v√° tenacity pro retry")
                
            if "CircuitBreaker" in content:
                checks.append("‚úÖ Implementuje Circuit Breaker pattern")
            else:
                checks.append("‚ùå Neimplementuje Circuit Breaker pattern")
                
            if "ErrorAggregator" in content:
                checks.append("‚úÖ M√° error aggregation")
            else:
                checks.append("‚ùå Nem√° error aggregation")
        else:
            checks.append("‚ùå Error handling modul neexistuje")
        
        # Check updated scrapers
        web_scraper_path = Path("src/scrapers/web_scraper.py")
        if web_scraper_path.exists():
            content = web_scraper_path.read_text()
            if "error_handling" in content and "retry" in content:
                checks.append("‚úÖ Web scraper pou≈æ√≠v√° robustn√≠ error handling")
            else:
                checks.append("‚ùå Web scraper nepou≈æ√≠v√° robustn√≠ error handling")
        
        tor_scraper_path = Path("src/scrapers/tor_scraper.py")
        if tor_scraper_path.exists():
            content = tor_scraper_path.read_text()
            if "error_handling" in content and "circuit_breaker" in content:
                checks.append("‚úÖ Tor scraper pou≈æ√≠v√° robustn√≠ error handling")
            else:
                checks.append("‚ùå Tor scraper nepou≈æ√≠v√° robustn√≠ error handling")
        
        success_rate = sum(1 for check in checks if check.startswith("‚úÖ")) / len(checks)
        self.results["task_1_3_error_handling"] = success_rate >= 0.8
        
        self.details.extend(checks)
        print(f"   √öspƒõ≈°nost: {success_rate:.1%}\n")
    
    def _validate_testing_framework(self):
        """√ökol 1.4: Zaveden√≠ testov√°n√≠ a statick√© anal√Ωzy"""
        print("üß™ Validuji √∫kol 1.4: Testov√°n√≠ a statick√° anal√Ωza")
        
        checks = []
        
        # Check pytest configuration
        pytest_ini_path = Path("pytest.ini")
        pyproject_path = Path("pyproject.toml")
        
        if pytest_ini_path.exists() or (pyproject_path.exists() and "pytest" in pyproject_path.read_text()):
            checks.append("‚úÖ Pytest konfigurace existuje")
        else:
            checks.append("‚ùå Pytest konfigurace neexistuje")
        
        # Check mypy configuration
        mypy_ini_path = Path("mypy.ini")
        if mypy_ini_path.exists() or (pyproject_path.exists() and "mypy" in pyproject_path.read_text()):
            checks.append("‚úÖ MyPy konfigurace existuje")
        else:
            checks.append("‚ùå MyPy konfigurace neexistuje")
        
        # Check test files
        test_files = list(Path("tests").glob("test_*.py")) if Path("tests").exists() else []
        if test_files:
            checks.append(f"‚úÖ Nalezeno {len(test_files)} testovac√≠ch soubor≈Ø")
        else:
            checks.append("‚ùå ≈Ω√°dn√© testovac√≠ soubory nenalezeny")
        
        # Check for dev dependencies
        if pyproject_path.exists():
            content = pyproject_path.read_text()
            dev_deps = ["pytest", "mypy", "ruff", "bandit"]
            found_deps = sum(1 for dep in dev_deps if dep in content)
            if found_deps >= 3:
                checks.append(f"‚úÖ V√Ωvojov√© z√°vislosti nalezeny ({found_deps}/4)")
            else:
                checks.append(f"‚ùå Chyb√≠ v√Ωvojov√© z√°vislosti ({found_deps}/4)")
        
        success_rate = sum(1 for check in checks if check.startswith("‚úÖ")) / len(checks)
        self.results["task_1_4_testing"] = success_rate >= 0.75
        
        self.details.extend(checks)
        print(f"   √öspƒõ≈°nost: {success_rate:.1%}\n")
    
    def _scan_for_hardcoded_secrets(self) -> List[str]:
        """Skenuje k√≥d pro hardcoded secrets"""
        suspicious_patterns = [
            "api_key",
            "secret_key", 
            "password",
            "token",
            "sk-", # OpenAI API keys
            "xoxb-", # Slack tokens
        ]
        
        found_secrets = []
        
        # Scan Python files
        for py_file in Path("src").rglob("*.py"):
            try:
                content = py_file.read_text()
                for pattern in suspicious_patterns:
                    if f'"{pattern}' in content or f"'{pattern}" in content:
                        # Check if it's not just a variable name
                        lines = content.split('\n')
                        for i, line in enumerate(lines):
                            if pattern in line and '=' in line and not line.strip().startswith('#'):
                                # Skip if it's loading from env
                                if 'os.getenv' not in line and 'env=' not in line:
                                    found_secrets.append(f"{py_file}:{i+1}")
            except Exception:
                continue
        
        return found_secrets
    
    def _calculate_overall_score(self):
        """Vypoƒç√≠t√° celkov√© sk√≥re"""
        task_scores = [
            self.results["task_1_1_poetry"],
            self.results["task_1_2_secrets"], 
            self.results["task_1_3_error_handling"],
            self.results["task_1_4_testing"]
        ]
        
        self.results["overall_score"] = (sum(task_scores) / len(task_scores)) * 100
    
    def _print_summary(self):
        """Vytiskne shrnut√≠ validace"""
        print("=" * 60)
        print("üìä SHRNUT√ç VALIDACE F√ÅZE 1")
        print("=" * 60)
        
        tasks = [
            ("1.1 Poetry spr√°va z√°vislost√≠", self.results["task_1_1_poetry"]),
            ("1.2 Spr√°va tajemstv√≠", self.results["task_1_2_secrets"]),
            ("1.3 Robustn√≠ error handling", self.results["task_1_3_error_handling"]),
            ("1.4 Testov√°n√≠ a anal√Ωza", self.results["task_1_4_testing"])
        ]
        
        for task_name, passed in tasks:
            status = "‚úÖ SPLNƒöNO" if passed else "‚ùå NESPLNƒöNO"
            print(f"{task_name:.<40} {status}")
        
        print("-" * 60)
        overall_status = "üéâ √öSPƒöCH" if self.results["overall_score"] >= 80 else "‚ö†Ô∏è  POT≈òEBUJE PR√ÅCI"
        print(f"Celkov√© sk√≥re: {self.results['overall_score']:.1f}% - {overall_status}")
        
        if self.results["overall_score"] >= 80:
            print("\nüöÄ F√°ze 1 je √∫spƒõ≈°nƒõ dokonƒçena! M≈Ø≈æete pokraƒçovat na F√°zi 2.")
        else:
            print("\nüîß F√°ze 1 pot≈ôebuje dal≈°√≠ pr√°ci p≈ôed pokraƒçov√°n√≠m na F√°zi 2.")
    
    def save_results(self, filename: str = "phase1_validation_results.json"):
        """Ulo≈æ√≠ v√Ωsledky validace do JSON souboru"""
        with open(filename, 'w') as f:
            json.dump({
                "phase": 1,
                "timestamp": "2025-08-30",
                "results": self.results,
                "details": self.details
            }, f, indent=2, ensure_ascii=False)
        
        print(f"\nüíæ V√Ωsledky ulo≈æeny do {filename}")


def main():
    """Hlavn√≠ funkce"""
    validator = Phase1Validator()
    results = validator.validate_all()
    validator.save_results()
    
    # Exit with appropriate code
    sys.exit(0 if results["passed"] else 1)


if __name__ == "__main__":
    main()